# Coding Convention & Lombok

코드의 가독성을 높이고, 현대적인 Java 문법을 통해 실수를 줄이며 생산성을 극대화하는데 목적이 있습니다.

## Google Java Style Guilde 준수

우리 프로젝트는 코드의 일관성을 위해 [Google Java Style Guide]를 기본 표준으로 채택합니다.

- 도입이유: 개인별 코딩 스타일 차이로 인한 코드 리뷰의 피로도를 줄이고, 전 세계적으로 검증된 가독성 표준을 따르기 위함이빈다.

- 핵심 준수 사항:
    - 들여쓰기는 2 space 를 사용합니다.
    - 클래스 멤버는 일정한 순서(필드 → 생성자 → 메서드)로 배치합니다.
    - import 시 와일드카드(*) 사용을 금지합니다.
- 자동화: IDE(IntellJ 등)에 Google Style 포맷터를 적용하여 저장 시 자동 정렬되도록 설정합니다.

### 구글 코드 스타일 보기

- [구글 코드 스타일 한글보기](../appendix/javaGoogleCodeStyleKor.md)
- [구글 코드 스타일 영문보기](https://google.github.io/styleguide/javaguide.html)

### Spring Boot 프로젝트에 구글 스타일 적용 방법

Spring Boot (Java) 개발자라면 IDE와 빌드 도구에 설정해서 자동으로 관리하는 것이 가장 편합니다.

- IntelliJ IDEA에서 설정하기
    1. 설정 파일 다운로드: [Google Style XML](https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml)파일을 받습니다.
    2. 적용: Setting > Editor > Code Style > Java 에서 톱니바퀴 아이콘 클릭 후 Import Scheme를 선택해 다운로드한 파일을 불러옵니다.

- CheckStyle 활용하기

프로젝트 빌드 시점에 컨벤션을 강제하고 싶다면 Checkstyle 플러그인을 사용합니다.
    - Gradle: checkstyle 플러그인 추가 및 google.checks.xml 설정

## Lombok 사용 가이드 라인

편리함을 취하되, 안정성을 위해 사용 범위를 제한합니다.
- 권장: @Getter, @RequiredArgsConstructor, @Builder, @Slf4j
- 금지:
    - @Data: 무분별한 Setter 생성 및 상호참조로 인한 StackOverflow 위함 때문
    - @AllArgsConstructor: 필드 순서가 바뀌었을 때 생성자 호출부에서 치명적인 데이터 오류가 발생할 수 있음.
    - Entity에서의 주의: JPA Entity에서는 @ToString 사용시 연관관계 무한 루프를 방지하기 위해 반드시 exclude처리를 합니다.

---

1. DTO (Data Transfer Object) 표준

JDK 21에서는 데이터를 전달하는 가방 역할로 record 를 우선 사용합니다.
하지만 Querydsl 사용이나 특정 라이브러리 호환성을 위한 클래스가 필요할 땐 Lombok을 사용합니다.

```java
package com.example.project.modules.user.dto;

import lombok.Builder;
import lombok.Getter;

@Builder
public Record UserResponse {
    
  private Long id;

  private String email;

  private String nickname;

  // Record 는 Getter, 생성자가 자동 생성되므로 코드가 매우 간결해집니다.
}
```

2. Service 클래스 표준

비즈니스 로직을 처리하는 서비스에서는 ``@RequiredArgsConstructor`` 와 ``@Slf4j`` 가 핵심입니다.

```java
package com.example.project.modules.user.service;

import com.example.project.modules.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.sterotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j // 로그 기록을 위한 Logger 객체 자동 생성
@Service
@RequiredArgsConstructor // final 이 붙은 필드만 모아서 생성자를 만들어줌 (생성자 주입)
public class UserService {
  // @RequiredArgsConstructor 덕분에 자동 주입됨
  private final UserRepository userRepository;

  @Transactional
  public void signUp(UserRequest request) {
    log.info("회원가입 시도: {}", request.email()); // @Slf4j 사용 예시
    
    // 비즈니스 로직
  }
}
```

왜 @RequiredArgsConstructor 인가? 스프링에서 의존성 주입(DI)을 할 때, 필드 주입 (@Autowired) 보다 생성자 주입이 테스트와 불변성 측면에서 휠씬 안전합니다.
Lombok을 쓰면 이 생성자를 일일이 타이핑할 필요가 없습습니다.

3. Entity 클래스 표준 (JPA 전용)
엔티티는 DB와 직결되므로 가장 보수적으로 접근해야 합니다.

```java
package com.example.project.modules.user.entity;

import jakarta.persistence.*;
import lombok.*

@Entity
@Getter
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED) // JPA를 위한 기본 생성자 (안전하게 PROTECTED)
@AllArgsConstructor(access = AccessLevel.PRIVATE) // Builder 사용을 위해 필요하지만 외부 노출 안함
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    // 로직에 필요한 수정 메서드는 별도로 의미 있게 작성 (setNickname ☓, updateNickname ◯)
    public void updateNickname(String newNickname) {
        this.nickname = newNickname;
    }
}
```